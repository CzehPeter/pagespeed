/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Code for deferring javascript on client side.
 * This javascript is part of JsDefer filter.
 *
 * @author atulvasu@google.com (Atul Vasu)
 */

// Exporting functions using quoted attributes to prevent js compiler from
// renaming them.
// See http://code.google.com/closure/compiler/docs/api-tutorial3.html#dangers
window['pagespeed'] = window['pagespeed'] || {};
var pagespeed = window['pagespeed'];

/**
 * @constructor
 */
pagespeed.DeferJs = function() {
  /**
   * Queue of tasks that need to be executed in order.
   * @type {!Array.<function()>}
   * @private
   */
  this.queue_ = [];

  /**
   * Array of logs, for debugging.
   * @type {Array.<string>}
   */
  this.logs = [];

  /**
   * Next item in the queue to be executed.
   * @type {!number}
   * @private
   */
  this.next_ = 0;

  /**
   * Nodes generated by document.write() are inserted before this element.
   * @type {Element}
   * @private
   */
  this.currentElem_ = null;

  /**
   * document.write() strings get buffered here, they get rendered when the
   * current script is finished executing.
   * @private
   */
  this.documentWriteHtml_ = '';

  /**
   * EvenListeners for DOMContentLoaded or onreadystatechange on document.
   */
  this.domReadyListeners_ = [];

  /**
   * EvenListeners for document.onload or window.onload
   * TODO(ksimbili): Handle body.onload. In IE body.onload is alias to
   * window.onload
   * TODO(ksimbili): onload set in HTML for other elements need to be handled
   * too.
   */
  this.pageLoadListeners_ = [];

  /**
   * Valid Mime types for Javascript.
   */
  this.jsMimeTypes =
      ['application/ecmascript',
       'application/javascript',
       'application/x-ecmascript',
       'application/x-javascript',
       'text/ecmascript',
       'text/javascript',
       'text/javascript1.0',
       'text/javascript1.1',
       'text/javascript1.2',
       'text/javascript1.3',
       'text/javascript1.4',
       'text/javascript1.5',
       'text/jscript',
       'text/livescript',
       'text/x-ecmascript',
       'text/x-javascript'];
};

/**
 * Add to defer_logs if logs are enabled.
 * @param {string} line line to be added to log.
 * @param {Error} opt_exception optional exception to pass to log.
 */
pagespeed.DeferJs.prototype.log = function(line, opt_exception) {
  if (this.logs) {
    this.logs.push('' + line);
    if (opt_exception) {
      this.logs.push(opt_exception);
    }
  }
};

/**
 * Adds task to the end of queue, unless position is explicitly given.
 * @param {!function()} task Function closure to be executed later.
 * @param {number} opt_pos optional position for ordering of jobs.
 */
pagespeed.DeferJs.prototype.submitTask = function(task, opt_pos) {
  var pos = opt_pos ? opt_pos : this.queue_.length;
  this.queue_.splice(pos, 0, task);
};

/**
 * @param {string} str to be evaluated.
 */
pagespeed.DeferJs.prototype.globalEval = function(str) {
  var script = document.createElement('script');
  script.text=str;
  script.setAttribute('type', 'text/javascript');
  this.currentElem_.parentNode.insertBefore(script, this.currentElem_);
};

/**
 * Defines a new var in the name of id's present in the doc. This is the fix for
 * IE, where setting value to the var with same name as an id in the doc throws
 * exception. While creating vars, skip the names which have '-', ':', '.'.
 * Also, variable names cannot start with digits.
 * These characters are allowed in id names but not allowed in variable
 * names.
 */
pagespeed.DeferJs.prototype.createIdVars = function() {
  var elems = document.getElementsByTagName("*");
  var idVarsString = "";
  for (var i = 0; i < elems.length; i++) {
    if (elems[i].id && elems[i].id.search(/[-:.]/) == -1 &&
        elems[i].id.search(/^[0-9]/) == -1) {
      if (window[elems[i].id] && window[elems[i].id].tagName) {
        idVarsString += 'var ' + elems[i].id +
            '=document.getElementById("' + elems[i].id + '");';
      }
    }
  }
  if (idVarsString) {
    this.globalEval(idVarsString);
  }
}

/**
 * Defers execution of scriptNode, by adding it to the queue.
 * @param {Element} script script node.
 * @param {Element} opt_elem Optional context element.
 * @param {number} opt_pos Optional position for ordering.
 */
pagespeed.DeferJs.prototype.addNode = function(script, opt_elem, opt_pos) {
  var src = script.getAttribute('orig_src') || script.getAttribute('src');
  if (src) {
    this.addUrl(src, opt_elem, opt_pos);
  }
  var str = script.innerHTML || script.textContent || script.data;
  if (str) {
    this.addStr(str, opt_elem, opt_pos);
  }
};

/**
 * Defers execution of 'str', by adding it to the queue.
 * @param {!string} str valid javascript snippet.
 * @param {Element} opt_elem Optional context element.
 * @param {number} opt_pos Optional position for ordering.
 */
pagespeed.DeferJs.prototype.addStr = function(str, opt_elem, opt_pos) {
  if (this.isFireFox()) {
    // This is due to some bug identified in firefox.
    // Got this workaround from the bug raised on firefox.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=728151
    this.addUrl('data:text/javascript,' + encodeURIComponent(str),
                opt_elem,
                opt_pos);
    return;
  }
  this.logs.push('Add to queue str: ' + str);
  var me = this; // capture closure.
  this.submitTask(function() {
    if (opt_elem) {
      me.currentElem_ = opt_elem;
    }
    try {
      me.globalEval(str);
    } catch (err) {
      me.log('Exception while evaluating.', err);
    }
    me.log('Evaluated: ' + str);
    // TODO(atulvasu): Detach stack here to prevent recursion issues.
    me.runNext();
  }, opt_pos);
};
pagespeed.DeferJs.prototype['addStr'] = pagespeed.DeferJs.prototype.addStr;

/**
 * Defers execution of contents of 'url'.
 * @param {!string} url returns javascript when fetched.
 * @param {Element} opt_elem Optional context element.
 * @param {number} opt_pos Optional position for ordering.
 */
pagespeed.DeferJs.prototype.addUrl = function(url, opt_elem, opt_pos) {
  this.logs.push('Add to queue url: ' + url);
  var me = this; // capture closure.
  this.submitTask(function() {
    if (opt_elem) {
      me.currentElem_ = opt_elem;
    }
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    var runNextHandler = function() {
      me.log('Executed: ' + url);
      me.runNext();
    };
    pagespeed.addOnload(script, runNextHandler);
    pagespeed.addHandler(script, 'error', runNextHandler);
    if (me.getIEVersion() < 9) {
      var stateChangeHandler = function() {
        if (script.readyState == 'complete' ||
            script.readyState == 'loaded') {
          script.onreadystatechange = null;
          runNextHandler();
        }
      }

      pagespeed.addHandler(script, 'readystatechange', stateChangeHandler);
    }
    script.setAttribute('src', url);
    me.currentElem_.parentNode.insertBefore(script, me.currentElem_);
  }, opt_pos);
};
pagespeed.DeferJs.prototype['addUrl'] = pagespeed.DeferJs.prototype.addUrl;

/**
 * Called when the script Queue execution is finished.
 */
pagespeed.DeferJs.prototype.onComplete = function() {
  // TODO(ksimbili): Restore the handlers in a clean way.
  if (document.originalAddEventListener) {
    document.addEventListener = document.originalAddEventListener;
    window.addEventListener = window.originalAddEventListener;
  } else if (document.originalAttachEvent) {
    document.attachEvent = document.originalAttachEvent;
    window.attachEvent = window.originalAttachEvent;
  }

  this.executeDomReady();
  this.executePageLoad();
}

/**
 * Schedules the next task in the queue.
 */
pagespeed.DeferJs.prototype.runNext = function() {
  this.handlePendingDocumentWrites();
  if (this.next_ < this.queue_.length) {
    // Done here to prevent another _run_next() in stack from
    // seeing the same value of next, and get into infinite
    // loop.
    this.next_++;
    this.queue_[this.next_ - 1].call(window);
  } else {
    this.onComplete();
  }
};

/**
 * Converts from NodeList to array of nodes.
 * @param {!NodeList} nodeList NodeList from a DOM node.
 * @return {!Array.<Node>} Array of nodes returned.
 */
pagespeed.DeferJs.prototype.nodeListToArray = function(nodeList) {
  var arr = [];
  var len = nodeList.length;
  for (var i = 0; i < len; ++i) {
    arr.push(nodeList.item(i));
  }
  return arr;
};

/**
 * Starts the execution of all the deferred scripts.
 */
pagespeed.DeferJs.prototype.run = function() {
  this.overrideAddEventListener(document);
  this.overrideAddEventListener(window);
  // TODO(atulvasu): Remove this once context is not optional.
  // Place where document.write() happens if there is no context element
  // present. Happens if there is no context registering that happened in
  // registerNoScriptTags.
  var initialContextNode = document.createElement('span');
  initialContextNode.setAttribute('psa_dw_target', 'true');
  document.body.appendChild(initialContextNode);
  this.currentElem_ = initialContextNode;
  if (this.getIEVersion()) {
    this.createIdVars();
  }

  // Starts executing the defer_js closures.
  this.runNext();
};
pagespeed.DeferJs.prototype['run'] = pagespeed.DeferJs.prototype.run;

/**
 * Parses the given html snippet.
 * @param {!string} html to be parsed.
 * @return {!Node} returns a DIV containing parsed nodes as children.
 */
pagespeed.DeferJs.prototype.parseHtml = function(html) {
  var div = document.createElement('div');
  // IE HACK -- Two options.
  // 1) Either add a dummy character at the start and delete it after parsing.
  // 2) Add some non-empty node infront of html.
  div.innerHTML = '<div>_</div>' + html;
  div.removeChild(div.firstChild);
  return div;
};

/**
 * Removes the node from its parent if it has one.
 * @param {Node} node Node to be disowned from parent.
 */
pagespeed.DeferJs.prototype.disown = function(node) {
  var parentNode = node.parentNode;
  if (parentNode) {
    parentNode.removeChild(node);
  }
};

/**
 * Inserts all the nodes before elem. It must have a parentNode for this
 * operation to succeed. (either actually inserted in DOM)
 * @param {!NodeList} nodes to insert.
 * @param {!Node} elem context element.
 */
pagespeed.DeferJs.prototype.insertNodesBeforeElem = function(nodes, elem) {
  var nodeArray = this.nodeListToArray(nodes);
  var len = nodeArray.length;
  var parentNode = elem.parentNode;
  for (var i = 0; i < len; ++i) {
    var node = nodeArray[i];
    this.disown(node);
    parentNode.insertBefore(node, elem);
  }
};

/**
 * Returns if the node is JavaScript Node.
 * @param {!Node} node valid script Node.
 * @return {boolean} true if script node is javascript node.
 */
pagespeed.DeferJs.prototype.isJSNode = function(node) {
  if (node.nodeName != 'SCRIPT') {
    return false;
  }

  if (node.hasAttribute('type')) {
      var type = node.getAttribute('type');
      return !type ||
             (this.jsMimeTypes.indexOf(type) != -1);
  } else if (node.hasAttribute('language')) {
      var lang = node.getAttribute('language');
      return !lang ||
             (this.jsMimeTypes.indexOf('text/' + lang.toLowerCase()) != -1);
  }
  return true;
};

/**
 * Given the list of nodes, separates into script nodes and regular nodes.
 * @param {!Node} node starting node for DFS.
 * @param {!Array.<Element>} scriptNodes array of script elements (output).
 */
pagespeed.DeferJs.prototype.extractScriptNodes = function(node, scriptNodes) {
  if (!node.childNodes) {
    return;
  }
  var nodeArray = this.nodeListToArray(node.childNodes);
  var len = nodeArray.length;
  for (var i = 0; i < len; ++i) {
    var child = nodeArray[i];
    if (child.nodeName == 'SCRIPT') {
      if (this.isJSNode(child)) {
        scriptNodes.push(child);
        this.disown(child);
      }
    } else {
      this.extractScriptNodes(child, scriptNodes);
    }
  }
};

/**
 * @param {!Array.<Element>} scripts Array of script nodes to be deferred.
 * @param {!number} pos position for script ordering.
 * @param {Element} opt_elem Optional context element.
 */
pagespeed.DeferJs.prototype.deferScripts = function(scripts, pos, opt_elem) {
  var len = scripts.length;
  for (var i = 0; i < len; ++i) {
    this.addNode(scripts[i], opt_elem, pos + i);
  }
};

/**
 * Inserts html in the before elem, with scripts inside added to queue at pos.
 * @param {!string} html contains the snippet.
 * @param {!number} pos optional position to add to queue.
 * @param {Element} opt_elem optional context element.
 */
pagespeed.DeferJs.prototype.insertHtml = function(html, pos, opt_elem) {
  // Parse the html.
  var node = this.parseHtml(html);

  // Extract script nodes out for deferring them.
  var scriptNodes = [];
  this.extractScriptNodes(node, scriptNodes);

  // Add non-script nodes before elem
  if (opt_elem) {
    this.insertNodesBeforeElem(node.childNodes, opt_elem);
  } else {
    this.log('Unable to insert nodes, no context element found');
  }

  // Add script nodes for deferring.
  this.deferScripts(scriptNodes, pos, opt_elem);
};

/**
 * Renders the document.write() buffer before the context
 * element.
 */
pagespeed.DeferJs.prototype.handlePendingDocumentWrites = function() {
  if (this.documentWriteHtml_ == '') {
    return;
  }
  this.log('handle_dw: ' + this.documentWriteHtml_);

  var html = this.documentWriteHtml_;
  // Reset early because insertHtml may internally end up calling this function
  // recursively.
  this.documentWriteHtml_ = '';

  this.insertHtml(html, this.next_, this.currentElem_);
};

/**
 * Writes html like document.write to the current context item.
 * @param {string} html Html to be written before current context elem.
 */
pagespeed.DeferJs.prototype.writeHtml = function(html) {
  this.log('dw: ' + html);
  this.documentWriteHtml_ += html;
};

/**
 * Adds DOMContentLoaded event listeners to our own list and called them later.
 * @param {!function()} func domReady listener.
 */
pagespeed.DeferJs.prototype.addDomReadyListeners = function(func) {
  this.log('domready: ' + func.toString());
  this.domReadyListeners_.push(func);
};

/**
 * Adds page onload event listeners to our own list and called them later.
 * @param {!function()} func onload listener.
 */
pagespeed.DeferJs.prototype.addPageLoadListeners = function(func) {
  this.log('onload: ' + func.toString());
  this.pageLoadListeners_.push(func);
};

/**
 * Execute all handlers registered for DOMContentLoaded/onreadystatechange.
 */
pagespeed.DeferJs.prototype.executeDomReady = function() {
  for (var i = 0; i < this.domReadyListeners_.length; i++) {
    this.log('executing domready: ' + this.domReadyListeners_[i].toString());
    this.domReadyListeners_[i].call(window);
  }
  if (document.onreadystatechange) {
    document.onreadystatechange();
  }
};

/**
 * Execute all handlers registered for page onload.
 */
pagespeed.DeferJs.prototype.executePageLoad = function() {
  for (var i = 0; i < this.pageLoadListeners_.length; i++) {
    this.log('executing pageload: ' + this.pageLoadListeners_[i].toString());
    this.pageLoadListeners_[i].call(window);
  }
};

/**
 * Adds the function to list of listeners based on event.
 * TODO(ksimbili): Store 'this' and call func on 'this'.
 * @param {Window|Element|Document} elem Element on which event is registered.
 * @param {!string} eventName Name of the event.
 * @param {!function()} func handler getting registered.
 * @param {Boolean} capture Capture event.
 */
var psaAddEventListener = function(elem, eventName, func, capture) {
  if (eventName == 'DOMContentLoaded' || eventName == 'readystatechange') {
    pagespeed.deferJs.addDomReadyListeners(func);
    return;
  }
  if (eventName == 'load') {
    pagespeed.deferJs.addPageLoadListeners(func);
    return;
  }
  elem.originalAddEventListener(eventName, func, capture);
};

/**
 * Adds the function to list of listeners based on event.
 * TODO(ksimbili): Store 'this' and call func on 'this'.
 * @param {Window|Element|Document} elem Element on which event is registered.
 * @param {!string} eventName Name of the event.
 * @param {!function()} func handler getting registered.
 */
var psaAttachEvent = function(elem, eventName, func) {
  if (eventName == 'onDOMContentLoaded' || eventName == 'onreadystatechange') {
    pagespeed.deferJs.addDomReadyListeners(func);
    return;
  }
  if (eventName == 'onload') {
    pagespeed.deferJs.addPageLoadListeners(func);
    return;
  }
  elem.originalAttachEvent(eventName, func);
};

/**
 * Override addEventListener/attachEvent of Element.
 * @param {Window|Element|Document} elem Element whose handler to be overriden.
 */
pagespeed.DeferJs.prototype.overrideAddEventListener = function(elem) {
  if (elem.addEventListener && !elem.originalAddEventListener) {
    elem.originalAddEventListener = elem.addEventListener;
    elem.addEventListener = function (eventName, func, capture) {
      psaAddEventListener(elem, eventName, func, capture);
    };
  } else if (elem.attachEvent && !elem.originalAttachEvent) {
    elem.originalAttachEvent = elem.attachEvent;
    elem.attachEvent = function (eventName, func) {
      psaAttachEvent(elem, eventName, func);
    };
  }
};

/**
 * Registers all script tags which are marked text/psajs, by adding themselves
 * as the context element to the script embedded inside them.
 */
pagespeed.DeferJs.prototype.registerScriptTags = function() {
  var scripts = document.getElementsByTagName('script');
  var len = scripts.length;
  for (var i = 0; i < len; ++i) {
    var script = scripts[i];
    // TODO(atulvasu): Use orig_type
    if (script.getAttribute('type') == 'text/psajs') {
      this.addNode(script, script);
    }
  }
};
pagespeed.DeferJs.prototype['registerScriptTags'] =
    pagespeed.DeferJs.prototype.registerScriptTags;

/**
 * Runs the function when element is loaded.
 * @param {Window|Element} elem Element to attach handler.
 * @param {!function()} func New onload handler.
 */
pagespeed.addOnload = function(elem, func) {
  pagespeed.addHandler(elem, 'load', func);
};
pagespeed['addOnload'] = pagespeed.addOnload;

/**
 * Runs the function when event is triggered.
 * @param {Window|Element} elem Element to attach handler.
 * @param {!string} eventName Name of the event.
 * @param {!function()} func New onload handler.
 */
pagespeed.addHandler = function(elem, eventName, func) {
  if (elem.addEventListener) {
    elem.addEventListener(eventName, func, false);
  } else if (elem.attachEvent) {
    elem.attachEvent('on' + eventName, func);
  } else {
    var oldHandler = elem['on' + eventName];
    elem['on' + eventName] = function() {
      func.call(this);
      if (oldHandler) {
        oldHandler.call(this);
      }
    }
  }
};
pagespeed['addHandler'] = pagespeed.addHandler;

/**
 * Returns the outerHTML of node in a browser independent fashion.
 * @param {!Element} node whose outerHTML is computed.
 * @return {string} html.
 */
pagespeed.outerHTML = function(node) {
  return node.outerHTML || new XMLSerializer().serializeToString(node);
};

/**
 * Returns true if browser is Firefox.
 */
pagespeed.DeferJs.prototype.isFireFox = function() {
  return (navigator.userAgent.indexOf("Firefox") != -1);
};

/**
 * Returns version number if browser is IE.
 */
pagespeed.DeferJs.prototype.getIEVersion = function() {
  var version = /(?:MSIE.(\d+\.\d+))/.exec(navigator.userAgent);
  return version && version[1] ? parseFloat(version[1]) : NaN;
};

/**
 * Initialize defer javascript.
 */
pagespeed.deferInit = function() {
  pagespeed.deferJs = new pagespeed.DeferJs();
  pagespeed['deferJs'] = pagespeed.deferJs;
  document.writeln = function(x) {
    pagespeed.deferJs.writeHtml(x + '\n');
  };
  document.write = function(x) {
    pagespeed.deferJs.writeHtml(x);
  };
};
pagespeed['deferInit'] = pagespeed.deferInit;

