/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Author: Huibao Lin

#include "pagespeed/kernel/base/gtest.h"
#include "pagespeed/kernel/base/message_handler.h"
#include "pagespeed/kernel/base/mock_message_handler.h"
#include "pagespeed/kernel/base/null_mutex.h"
#include "pagespeed/kernel/base/string.h"
#include "pagespeed/kernel/image/png_optimizer.h"
#include "pagespeed/kernel/image/read_image.h"
#include "pagespeed/kernel/image/test_utils.h"
#include "pagespeed/kernel/image/webp_optimizer.h"

namespace {

using net_instaweb::MockMessageHandler;
using net_instaweb::NullMutex;
using pagespeed::image_compression::IMAGE_PNG;
using pagespeed::image_compression::IMAGE_WEBP;
using pagespeed::image_compression::kPngSuiteTestDir;
using pagespeed::image_compression::kWebpTestDir;
using pagespeed::image_compression::PixelFormat;
using pagespeed::image_compression::PngScanlineReaderRaw;
using pagespeed::image_compression::ReadTestFile;
using pagespeed::image_compression::RGB_888;
using pagespeed::image_compression::RGBA_8888;
using pagespeed::image_compression::ScanlineWriterInterface;
using pagespeed::image_compression::WebpConfiguration;
using pagespeed::image_compression::WebpScanlineReader;
using pagespeed::image_compression::WebpScanlineWriter;
using pagespeed::image_compression::kMessagePatternPixelFormat;
using pagespeed::image_compression::kMessagePatternStats;
using pagespeed::image_compression::kMessagePatternWritingToWebp;

// Each file in kValidImages is saved in both PNG format and WebP format.
// alpha_32x32.webp is lossless, while opaque_32x20.webp is lossy.
// alpha_32x32.png and opaque_32x20.png were generated by 'dwebp' from the
// corresponding WebP images.
const char* kValidImages[] = {
  "alpha_32x32",    // size 32-by-32 with alpha.
  "opaque_32x20",   // size 32-by-20 without alpha.
};
const size_t kValidImageCount = arraysize(kValidImages);

const char kFileCorruptedHeader[] = "corrupt_header";
const char kFileCorruptedBody[] = "corrupt_body";
const double kMinPSNR = 33.0;

// Message to ignore.
const char kMessagePatternInvalidWebPData[] = "Invalid WebP data.";

class WebpScanlineReaderTest : public testing::Test {
 public:
  WebpScanlineReaderTest()
    : message_handler_(new NullMutex),
      reader_(&message_handler_),
      scanline_(NULL) {
  }

  bool Initialize(const char* file_name) {
    if (!ReadTestFile(kWebpTestDir, file_name, "webp", &input_image_)) {
      PS_LOG_ERROR((&message_handler_), "Failed to read file: %s", file_name);
      return false;
    }
    return reader_.Initialize(input_image_.c_str(), input_image_.length());
  }

  void ConvertPngToWebp(const GoogleString& png_image,
                        const WebpConfiguration& webp_config,
                        GoogleString* webp_image) {
    PngScanlineReaderRaw png_reader(&message_handler_);
    // Initialize a PNG reader for reading the original image.
    ASSERT_TRUE(png_reader.Initialize(
        png_image.data(), png_image.length()));

    // Get the sizes and pixel format of the original image.
    const size_t width = png_reader.GetImageWidth();
    const size_t height = png_reader.GetImageHeight();
    const PixelFormat pixel_format = png_reader.GetPixelFormat();

    // WebP only supports RGB_888 and RGBA_8888.
    ASSERT_TRUE(pixel_format == RGB_888 || pixel_format == RGBA_8888);

    // Create a WebP writer.
    scoped_ptr<ScanlineWriterInterface> webp_writer(
        CreateScanlineWriter(pagespeed::image_compression::IMAGE_WEBP,
                             pixel_format, width, height, &webp_config,
                             webp_image, &message_handler_));
    ASSERT_NE(reinterpret_cast<ScanlineWriterInterface*>(NULL),
              webp_writer.get());

    // Read the scanlines from the original image and write them to the new one.
    while (png_reader.HasMoreScanLines()) {
      uint8* scanline = NULL;
      ASSERT_TRUE(png_reader.ReadNextScanline(
          reinterpret_cast<void**>(&scanline)));
      ASSERT_TRUE(webp_writer->WriteNextScanline(
          reinterpret_cast<void*>(scanline)));
    }
    ASSERT_TRUE(webp_writer->FinalizeWrite());
  }

 protected:
  virtual void SetUp() {
    message_handler_.AddPatternToSkipPrinting(kMessagePatternInvalidWebPData);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternPixelFormat);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternStats);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternWritingToWebp);
  }

 protected:
  MockMessageHandler message_handler_;
  WebpScanlineReader reader_;
  GoogleString input_image_;
  void* scanline_;

 private:
  DISALLOW_COPY_AND_ASSIGN(WebpScanlineReaderTest);
};

// Verify that decoded image is accurate for each pixel. The WebP image is
// compressed in lossy format. The gold data is dynamically generated.
TEST_F(WebpScanlineReaderTest, ConvertToAndReadLossyWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = false;
  webp_config.quality = 90;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ConvertPngToWebp(png_image, webp_config, &webp_image);
    DecodeAndCompareImagesByPSNR(IMAGE_PNG, png_image.c_str(),
                                 png_image.length(), IMAGE_WEBP,
                                 webp_image.c_str(), webp_image.length(),
                                 kMinPSNR, &message_handler_);
  }
}

// Verify that decoded image is accurate for each pixel. The WebP image is
// compressed in lossless format.
TEST_F(WebpScanlineReaderTest, ConvertToAndReadLosslessWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ConvertPngToWebp(png_image, webp_config, &webp_image);
    DecodeAndCompareImages(IMAGE_PNG, png_image.c_str(), png_image.length(),
                           IMAGE_WEBP, webp_image.c_str(),
                           webp_image.length(), &message_handler_);
  }
}

// Verify that decoded image is accurate for each pixel. The gold data was
// loaded from disk.
TEST_F(WebpScanlineReaderTest, CompareToWebpGolds) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i], "png", &png_image);
    ReadTestFile(kWebpTestDir, kValidImages[i], "webp", &webp_image);
    DecodeAndCompareImagesByPSNR(IMAGE_PNG, png_image.c_str(),
                                 png_image.length(), IMAGE_WEBP,
                                 webp_image.c_str(), webp_image.length(), 55,
                                 &message_handler_);
  }
}

TEST_F(WebpScanlineReaderTest, InitializeWithoutRead) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
}

TEST_F(WebpScanlineReaderTest, ReadOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, ReinitializeAfterOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, ReInitializeAfterLastRow) {
  ASSERT_TRUE(Initialize(kValidImages[0]));
  while (reader_.HasMoreScanLines()) {
    ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  }
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1]));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineReaderTest, InvalidWebpHeader) {
  ASSERT_FALSE(Initialize(kFileCorruptedHeader));
}

TEST_F(WebpScanlineReaderTest, InvalidWebpBody) {
  ASSERT_TRUE(Initialize(kFileCorruptedBody));
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
}

}  // namespace
