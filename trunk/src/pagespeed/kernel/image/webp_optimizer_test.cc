/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Author: Huibao Lin

#include "pagespeed/kernel/base/gtest.h"
#include "pagespeed/kernel/base/message_handler.h"
#include "pagespeed/kernel/base/mock_message_handler.h"
#include "pagespeed/kernel/base/null_mutex.h"
#include "pagespeed/kernel/base/string.h"
#include "pagespeed/kernel/image/png_optimizer.h"
#include "pagespeed/kernel/image/read_image.h"
#include "pagespeed/kernel/image/test_utils.h"
#include "pagespeed/kernel/image/webp_optimizer.h"

namespace {

using net_instaweb::MockMessageHandler;
using net_instaweb::NullMutex;
using pagespeed::image_compression::IMAGE_PNG;
using pagespeed::image_compression::IMAGE_WEBP;
using pagespeed::image_compression::kPngSuiteTestDir;
using pagespeed::image_compression::kWebpTestDir;
using pagespeed::image_compression::PixelFormat;
using pagespeed::image_compression::PngScanlineReaderRaw;
using pagespeed::image_compression::ReadTestFile;
using pagespeed::image_compression::RGB_888;
using pagespeed::image_compression::RGBA_8888;
using pagespeed::image_compression::ScanlineReaderInterface;
using pagespeed::image_compression::ScanlineWriterInterface;
using pagespeed::image_compression::WebpConfiguration;
using pagespeed::image_compression::WebpScanlineReader;
using pagespeed::image_compression::WebpScanlineWriter;
using pagespeed::image_compression::kMessagePatternPixelFormat;
using pagespeed::image_compression::kMessagePatternStats;
using pagespeed::image_compression::kMessagePatternWritingToWebp;

struct ImageInfo {
  const char* original_file;
  const char* gold_file;
};

// Each file in kValidImages is saved in both PNG format and WebP format.
// alpha_32x32.webp is lossless, while opaque_32x20.webp is lossy.
// alpha_32x32.png and opaque_32x20.png were generated by 'dwebp' from the
// corresponding WebP images. pagespeed_32x32_gray.png and
// pagespeed_32x32_rgb.png have the same pixel values, but are stored in
// different formats.
const ImageInfo kValidImages[] = {
  {"alpha_32x32", "alpha_32x32"},         // size 32-by-32 with alpha.
  {"opaque_32x20", "opaque_32x20"},       // size 32-by-20 without alpha.
  {"gray_saved_as_gray", "gray_saved_as_rgb"},  // images of same contents.
};
const size_t kValidImageCount = arraysize(kValidImages);

const char kFileCorruptedHeader[] = "corrupt_header";
const char kFileCorruptedBody[] = "corrupt_body";
const double kMinPSNR = 33.0;

// Message to ignore.
const char kMessagePatternInvalidWebPData[] = "Invalid WebP data.";

class WebpScanlineOptimizerTest : public testing::Test {
 public:
  WebpScanlineOptimizerTest()
    : message_handler_(new NullMutex),
      reader_(&message_handler_),
      scanline_(NULL) {
  }

  bool Initialize(const char* file_name) {
    if (!ReadTestFile(kWebpTestDir, file_name, "webp", &input_image_)) {
      PS_LOG_ERROR((&message_handler_), "Failed to read file: %s", file_name);
      return false;
    }
    return reader_.Initialize(input_image_.c_str(), input_image_.length());
  }

  void ConvertPngToWebp(const GoogleString& png_image,
                        const WebpConfiguration& webp_config,
                        GoogleString* webp_image) {
    PngScanlineReaderRaw png_reader(&message_handler_);
    // Initialize a PNG reader for reading the original image.
    ASSERT_TRUE(png_reader.Initialize(
        png_image.data(), png_image.length()));

    // Get the sizes and pixel format of the original image.
    const size_t width = png_reader.GetImageWidth();
    const size_t height = png_reader.GetImageHeight();
    const PixelFormat pixel_format = png_reader.GetPixelFormat();

    // Create a WebP writer.
    scoped_ptr<ScanlineWriterInterface> webp_writer(
        CreateScanlineWriter(pagespeed::image_compression::IMAGE_WEBP,
                             pixel_format, width, height, &webp_config,
                             webp_image, &message_handler_));
    ASSERT_NE(reinterpret_cast<ScanlineWriterInterface*>(NULL),
              webp_writer.get());

    // Read the scanlines from the original image and write them to the new one.
    while (png_reader.HasMoreScanLines()) {
      uint8* scanline = NULL;
      ASSERT_TRUE(png_reader.ReadNextScanline(
          reinterpret_cast<void**>(&scanline)));
      ASSERT_TRUE(webp_writer->WriteNextScanline(
          reinterpret_cast<void*>(scanline)));
    }
    ASSERT_TRUE(webp_writer->FinalizeWrite());
  }

 protected:
  virtual void SetUp() {
    message_handler_.AddPatternToSkipPrinting(kMessagePatternInvalidWebPData);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternPixelFormat);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternStats);
    message_handler_.AddPatternToSkipPrinting(kMessagePatternWritingToWebp);
  }

 protected:
  MockMessageHandler message_handler_;
  WebpScanlineReader reader_;
  GoogleString input_image_;
  void* scanline_;

 private:
  DISALLOW_COPY_AND_ASSIGN(WebpScanlineOptimizerTest);
};

// Test both WebP writer and reader. It is done by encoding an image to WebP
// format, then decoding the image and comparing with the gold image. The image
// is encoded as lossy format.
TEST_F(WebpScanlineOptimizerTest, ConvertToAndReadLossyWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = false;
  webp_config.quality = 90;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString original_image, gold_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i].original_file, "png",
                 &original_image);
    ConvertPngToWebp(original_image, webp_config, &webp_image);
    ReadTestFile(kWebpTestDir, kValidImages[i].gold_file, "png",
                 &gold_image);
    DecodeAndCompareImagesByPSNR(IMAGE_PNG, gold_image.c_str(),
                                 gold_image.length(), IMAGE_WEBP,
                                 webp_image.c_str(), webp_image.length(),
                                 kMinPSNR, &message_handler_);
  }
}

// Test both WebP writer and reader. It is done by encoding an image to WebP
// format, then decoding the image and comparing with the gold image. The image
// is encoded as lossless format.
TEST_F(WebpScanlineOptimizerTest, ConvertToAndReadLosslessWebp) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString original_image, gold_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i].original_file, "png",
                 &original_image);
    ConvertPngToWebp(original_image, webp_config, &webp_image);
    ReadTestFile(kWebpTestDir, kValidImages[i].gold_file, "png",
                 &gold_image);
    DecodeAndCompareImages(IMAGE_PNG, gold_image.c_str(), gold_image.length(),
                           IMAGE_WEBP, webp_image.c_str(),
                           webp_image.length(), &message_handler_);
  }
}

// Verify that decoded image is accurate as determined by PSNR.
// The gold data was loaded from disk.
TEST_F(WebpScanlineOptimizerTest, CompareToWebpGolds) {
  WebpConfiguration webp_config;
  webp_config.lossless = true;

  for (size_t i = 0; i < kValidImageCount; ++i) {
    GoogleString png_image, webp_image;
    ReadTestFile(kWebpTestDir, kValidImages[i].gold_file, "png", &png_image);
    ReadTestFile(kWebpTestDir, kValidImages[i].gold_file, "webp", &webp_image);
    DecodeAndCompareImagesByPSNR(IMAGE_PNG, png_image.c_str(),
                                 png_image.length(), IMAGE_WEBP,
                                 webp_image.c_str(), webp_image.length(), 55,
                                 &message_handler_);
  }
}

TEST_F(WebpScanlineOptimizerTest, InitializeWithoutRead) {
  ASSERT_TRUE(Initialize(kValidImages[0].original_file));
}

TEST_F(WebpScanlineOptimizerTest, ReadOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0].original_file));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineOptimizerTest, ReinitializeAfterOneRow) {
  ASSERT_TRUE(Initialize(kValidImages[0].original_file));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1].original_file));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineOptimizerTest, ReInitializeAfterLastRow) {
  ASSERT_TRUE(Initialize(kValidImages[0].original_file));
  while (reader_.HasMoreScanLines()) {
    ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
  }
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
  ASSERT_TRUE(Initialize(kValidImages[1].original_file));
  ASSERT_TRUE(reader_.ReadNextScanline(&scanline_));
}

TEST_F(WebpScanlineOptimizerTest, InvalidWebpHeader) {
  ASSERT_FALSE(Initialize(kFileCorruptedHeader));
}

TEST_F(WebpScanlineOptimizerTest, InvalidWebpBody) {
  ASSERT_TRUE(Initialize(kFileCorruptedBody));
  ASSERT_FALSE(reader_.ReadNextScanline(&scanline_));
}

}  // namespace
